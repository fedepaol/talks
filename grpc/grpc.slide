RPC on steroids with Go and Grpc

Federico Paolinelli
Red Hat
@fedepaol
fedepaol@gmail.com
fpaoline@redhat.com

* About me

- Red Hatter
- Doing distributed systems for more than 15 years
- CNV Networking team -> KubeVirt
- Open source enthusiast

* Let's talk about RPC

* All but a new thing

- Corba
- Wsdl
- Java RMI
- Com (?)

:  allow function callers and function implementers to live in different processes
: the client and the server in an RPC exchange must be up and running at the same time.
: language indpendent definition of the Rpc

* The need for communication

- Inter microservices
- Frontend / backend

* What options do I have?

- rest
- websockets
- framed tcp
- other rpcs (thrift, avro)
: rest is the king here. Not type safe. I know there are tools to generate the client /server but still
: websockets is not really a standard
: framed tcp: NIH syndrome

* Enters Grpc
: stands for Grpc remote procedure calls
: iteration of google's stubby, then opensourced

* Protocol Buffers

*Types*definition*

    message Person {
        required string name = 1;
        required int32 id = 2;
        optional string email = 3;
    }

*Services*definition*

    service HelloService {
        rpc SayHello (HelloRequest) returns (HelloResponse);
        rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse);
        rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse);
    }


: Default serialization mechanism for Grpc
: Run the protoc compiler and get data classes + serialization / deserialization
: New fields can be added without breaking retro compatibility
: if we have a router service that needs to propagate the data, can parse only the fields it knows and
: propagate the data
: sync call, streamed result, streamed in

