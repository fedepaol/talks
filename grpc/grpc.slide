RPC on steroids with Go and Grpc

Federico Paolinelli
Red Hat
@fedepaol
fedepaol@gmail.com
fpaoline@redhat.com

* About me

- Red Hatter
- Doing distributed systems for more than 15 years
- CNV Networking team -> KubeVirt
- Open source enthusiast

* Let's talk about RPC

* All but a new thing

- Corba
- Wsdl
- Java RMI
- Com (?)

:  allow function callers and function implementers to live in different processes
: the client and the server in an RPC exchange must be up and running at the same time.
: language indpendent definition of the Rpc

* The need for communication

- Inter microservices
- Frontend / backend

* What options do I have?

- rest
- websockets
- framed tcp
- other rpcs (thrift, avro)
: rest is the king here. Not type safe. I know there are tools to generate the client /server but still
: websockets is not really a standard
: framed tcp: NIH syndrome

* Enters Grpc
: stands for Grpc remote procedure calls
: iteration of google's stubby, then opensourced

* Protocol Buffers

*Types*definition*

    message Beer {
        int32 bid = 1;
        string beer_name = 2;
        string beer_description = 3;
        string beer_style = 4;
    }

*Services*definition*

    service BeersService {
        rpc GetBeer(BeerID) returns (Beer);
        rpc QueryBeer(BeerQueryParams) returns (stream Beer);
    }


: Default serialization mechanism for Grpc
: Run the protoc compiler and get data classes + serialization / deserialization
: New fields can be added without breaking retro compatibility
: if we have a router service that needs to propagate the data, can parse only the fields it knows and
: propagate the data
: sync call, streamed result, streamed in

* Server side

    type BeersServiceServer interface {
        GetBeer(context.Context, *BeerID) (*Beer, error)
        QueryBeer(*BeerQueryParams, BeersService_QueryBeerServer) error
    }

*Client*side*
    
    // Generated code
    func NewBeersServiceClient(cc *grpc.ClientConn) BeersServiceClient
    func (c *beersServiceClient) GetBeer(ctx context.Context, in *BeerID, opts ...grpc.CallOption) (*Beer, error)

* Server implementation

    func (b *BeerServer) GetBeer(ctx context.Context, id *beer.BeerID) (*beer.Beer, error) {
        beerID := id.GetBid()
        beer, ok := b.beers[int(beerID)]
        if !ok {
            // from google.golang.org/grpc/status
            return nil, status.Error(codes.NotFound, "beer not found")
        }
        return &beer, nil
    }

: convenience method to avoid npes
: grpc comes with a grpc/status package to provide rich errors